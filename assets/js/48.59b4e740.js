(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{477:function(a,t,e){"use strict";e.r(t);var n=e(15),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"bean的生命周期-了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean的生命周期-了解"}},[a._v("#")]),a._v(" Bean的生命周期（了解）")]),a._v(" "),e("blockquote",[e("p",[a._v("Spring的生命周期可以分为4个阶段：")]),a._v(" "),e("ol",[e("li",[a._v("实例化")]),a._v(" "),e("li",[a._v("属性注入")]),a._v(" "),e("li",[a._v("初始化")]),a._v(" "),e("li",[a._v("销毁")])])]),a._v(" "),e("h2",{attrs:{id:"实例化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例化"}},[a._v("#")]),a._v(" 实例化")]),a._v(" "),e("p",[a._v("通过反射获取类的定义信息，进行对象实例化")]),a._v(" "),e("h2",{attrs:{id:"依赖注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入"}},[a._v("#")]),a._v(" 依赖注入")]),a._v(" "),e("p",[a._v("在容器中，将对象中使用注解标注的成员变量的对象引用通过构造方法或set方法注入进来")]),a._v(" "),e("p",[a._v("实例化bean的过程中，需要解决bean之间的依赖问题，引入了依赖注入(DI)这种技术")]),a._v(" "),e("blockquote",[e("p",[a._v("Tip：")]),a._v(" "),e("p",[a._v("所有Aware接口的作用：属性注入")])]),a._v(" "),e("h2",{attrs:{id:"beannameaware接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beannameaware接口"}},[a._v("#")]),a._v(" BeanNameAware接口")]),a._v(" "),e("p",[a._v("对象实现该接口，可以在容器初始化后获取对象在spring容器中的id名称")]),a._v(" "),e("h2",{attrs:{id:"beanfactoryaware接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beanfactoryaware接口"}},[a._v("#")]),a._v(" BeanFactoryAware接口")]),a._v(" "),e("p",[a._v("在容器加载的时候，通过回调该接口的方法传入beanfactory实例给实现了该接口的对象")]),a._v(" "),e("p",[a._v("作用：让Bean获取配置他们的BeanFactory的引用")]),a._v(" "),e("p",[a._v("最常用实现是XmlBeanFactory")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("特性")]),a._v(" "),e("th",[a._v("BeanFactory")]),a._v(" "),e("th",[a._v("ApplicationContext")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("Bean 实例化/装配")]),a._v(" "),e("td",[a._v("Yes")]),a._v(" "),e("td",[a._v("Yes")])]),a._v(" "),e("tr",[e("td",[a._v("自动 BeanPostProcessor 注册")]),a._v(" "),e("td",[a._v("No")]),a._v(" "),e("td",[a._v("Yes")])]),a._v(" "),e("tr",[e("td",[a._v("自动 BeanFactoryPostProcessor 注册")]),a._v(" "),e("td",[a._v("No")]),a._v(" "),e("td",[a._v("Yes")])]),a._v(" "),e("tr",[e("td",[a._v("便捷的 MessageSource 访问( i18n)")]),a._v(" "),e("td",[a._v("No")]),a._v(" "),e("td",[a._v("Yes")])]),a._v(" "),e("tr",[e("td",[a._v("ApplicationEvent 发送")]),a._v(" "),e("td",[a._v("No")]),a._v(" "),e("td",[a._v("Yes")])])])]),a._v(" "),e("blockquote",[e("p",[a._v("Tip:")]),a._v(" "),e("p",[a._v("不推荐使用，因为结果是进一步加大Bean与Spring的耦合，所以能通过DI注入进来的尽量通过DI来注入")])]),a._v(" "),e("h2",{attrs:{id:"applicationcontextaware接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontextaware接口"}},[a._v("#")]),a._v(" ApplicationContextAware接口")]),a._v(" "),e("p",[a._v("从已有的spring上下文取得已实例化的bean，获取spring上下文对象。")]),a._v(" "),e("p",[a._v("在一些自定义的类中，不能够通过属性注入的方式注入，可以通过对实现该接口的类进行封装获取容器中的对象。")]),a._v(" "),e("h2",{attrs:{id:"beanpostprocessor-后置处理器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beanpostprocessor-后置处理器"}},[a._v("#")]),a._v(" BeanPostProcessor：后置处理器")]),a._v(" "),e("p",[a._v("作用：bean的自定义初始化方法前后进行处理工作")]),a._v(" "),e("p",[a._v("作用域：全局，容器中的所有的对象")]),a._v(" "),e("p",[a._v('bean指定组建的init方法和destroy的三种方法\n1：在配置类中 @Bean(initMethod = "init",destroyMethod = "destory")注解指定\n2：实现InitializingBean接口重写其afterPropertiesSet方法，实现DisposableBean接口重写destroy方法\n3：利用java的JSR250规范中的@PostConstruct标注在init方法上，@PreDestroy标注在destroy注解上')]),a._v(" "),e("p",[a._v("案例演示：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[main] INFO  org.example.bean.Account - bean 初始化\n[main] INFO  org.example.bean.AccountBeanPostProcessor - account PostProcess Before Initialization...\n[main] INFO  org.example.bean.Account - custom init method\n[main] INFO  org.example.bean.AccountBeanPostProcessor - account PostProcess After Initialization...\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("blockquote",[e("p",[a._v("Tip:")]),a._v(" "),e("p",[a._v("这是一个容器级生命周期接口方法，它独立于Bean，以容器附加装置的形式注册到Spring容器中，当Spring容器创建Bean的时候，这中“后处理器”都会发生作用，影响性是全局的")])]),a._v(" "),e("h2",{attrs:{id:"initializingbean接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#initializingbean接口"}},[a._v("#")]),a._v(" InitializingBean接口")]),a._v(" "),e("p",[a._v("为bean提供了初始化方法的方式")]),a._v(" "),e("p",[a._v("与"),e("code",[a._v("init-method")]),a._v("方法的功能相同")]),a._v(" "),e("p",[a._v("spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中同过init-method指定。两种方式可以同时使用，如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。")]),a._v(" "),e("h2",{attrs:{id:"disposablebean接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#disposablebean接口"}},[a._v("#")]),a._v(" DisposableBean接口")]),a._v(" "),e("p",[a._v("在容器关闭前，调用对象的自定义销毁destory方法")]),a._v(" "),e("p",[a._v("作用域：单例对象")]),a._v(" "),e("p",[a._v("与 "),e("code",[a._v("destroy-method")]),a._v("方法的功能相同")])])}),[],!1,null,null,null);t.default=s.exports}}]);