(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{451:function(v,_,t){"use strict";t.r(_);var l=t(15),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"范式存在的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范式存在的意义"}},[v._v("#")]),v._v(" 范式存在的意义")]),v._v(" "),t("ul",[t("li",[v._v("解决数据库字段冗余的问题")])]),v._v(" "),t("h4",{attrs:{id:"数据库冗余的表现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库冗余的表现"}},[v._v("#")]),v._v(" 数据库冗余的表现")]),v._v(" "),t("ul",[t("li",[v._v("插入异常")]),v._v(" "),t("li",[v._v("修改异常")]),v._v(" "),t("li",[v._v("删除异常")])]),v._v(" "),t("h4",{attrs:{id:"范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范式"}},[v._v("#")]),v._v(" 范式")]),v._v(" "),t("ul",[t("li",[v._v("第一范式(1NF)\n"),t("ul",[t("li",[v._v("如果关系模式"),t("em",[v._v("R")]),v._v("中所有的属性都是基本属性，即每个属性都是不可再分的，则称"),t("em",[v._v("R")]),v._v("属于第一范式，简称1NF，记作R∈1NF")])])])]),v._v(" "),t("ul",[t("li",[v._v("通俗地说，一张数据库表中的属性不可拆分或无重复的属性 。数据表中的每一列（每个字段）必须是不可拆分的最小单元，确保每一列的原子性\n"),t("ul",[t("li",[v._v("上述冗余的表现，在不满足第一范式的情况下都存在")])])])]),v._v(" "),t("ul",[t("li",[v._v("第二范式\n"),t("ul",[t("li",[v._v("如果关系模式"),t("em",[v._v("R")]),v._v("∈1NF，并且"),t("em",[v._v("R")]),v._v("中的每个非主属性都"),t("strong",[v._v("完全函数依赖")]),v._v("于主码，则称"),t("em",[v._v("R")]),v._v("属于第二范式，简称2NF，记作R∈2NF")]),v._v(" "),t("li",[v._v("通俗地说，一张数据表中的属性只描述一件事情，消除"),t("strong",[v._v("部分函数依赖")]),v._v("的字段。除了主键以外的其它列，都依赖与该主键，不能有任何一列与主键没有关系")])])])]),v._v(" "),t("ul",[t("li",[v._v("仍有数据冗余，发生数据操作异常的地方在非主属性的字段上\n"),t("ul",[t("li",[v._v("插入数据异常")]),v._v(" "),t("li",[v._v("删除数据异常")])])])]),v._v(" "),t("ul",[t("li",[v._v("第三范式\n"),t("ul",[t("li",[v._v("如果关系模式R∈2NF，非主属性之间不存在函数依赖, 则称R属于第三范式，简称3NF，记作R∈3NF")]),v._v(" "),t("li",[v._v("通俗地说，在第二范式的基础上消除非主属性之间的函数依赖所造成非主属性字段与主键列产生的"),t("strong",[v._v("传递依赖")]),v._v("。要求表中的非主属性的列与主键是直接相关的关系，而非间接关联")])])])]),v._v(" "),t("h4",{attrs:{id:"数据库约束"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库约束"}},[v._v("#")]),v._v(" 数据库约束")]),v._v(" "),t("ul",[t("li",[v._v("PRIMARY KEY：设置主键约束")]),v._v(" "),t("li",[v._v("UNIQUE：设置唯一性约束，不能有重复值")]),v._v(" "),t("li",[v._v("DEFAULT：默认值约束\n"),t("ul",[t("li",[v._v("For example：height DOUBLE(3,2) DEFAULT 1.2，height没有输入时，默认为1.2")])])]),v._v(" "),t("li",[v._v("NOT NULL：设置非空约束，该字段不能为空")]),v._v(" "),t("li",[v._v("FOREIGN key ：设置外键约束")])]),v._v(" "),t("h4",{attrs:{id:"如何更好的区分三大范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何更好的区分三大范式"}},[v._v("#")]),v._v(" 如何更好的区分三大范式？")]),v._v(" "),t("p",[v._v("​        第一范式和第二范式在于有没有分出两张表，第二范式是说一张表中包含了多种不同的实体属性，那么必须分成多张表， 第三范式是要求已经分成了多张表，那么一张表中只能有另一张表中的id（主键），而不能有其他的任何信息（其他的信息一律用主键在另一表查询）。")]),v._v(" "),t("h4",{attrs:{id:"范式中的键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范式中的键"}},[v._v("#")]),v._v(" 范式中的键？")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("主键：可以唯一标识的属性")])]),v._v(" "),t("li",[t("p",[v._v("非主属性：不包含任何一个候选码的属性")])]),v._v(" "),t("li",[t("p",[v._v("候选码：能够唯一标识的属性集合")])])]),v._v(" "),t("h4",{attrs:{id:"数据库表中的键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库表中的键"}},[v._v("#")]),v._v(" 数据库表中的键")]),v._v(" "),t("h6",{attrs:{id:"主键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主键"}},[v._v("#")]),v._v(" <主键>")]),v._v(" "),t("ul",[t("li",[v._v("主键默认非空，唯一性约束，自动增长一定是主键，主键不一定需要自动增长")]),v._v(" "),t("li",[v._v("两种设置方式\n"),t("ul",[t("li",[v._v("在定义列时设置：ID INT PRIMARY KEY")]),v._v(" "),t("li",[v._v("在列定义完之后设置：PRIMARY  KEY（id）")])])])]),v._v(" "),t("h6",{attrs:{id:"外键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外键"}},[v._v("#")]),v._v(" <外键>")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("设置语法")]),v._v(" "),t("ul",[t("li",[v._v("CONSTRAINT 外键名 FOREIGN KEY (外键字段)REFERENCES 参照表 (参照字段)ON DELETE SET NULL ON UPDATE CASCADE 设置参照完整性")])])]),v._v(" "),t("li",[t("p",[v._v("约束")]),v._v(" "),t("ul",[t("li",[v._v("外键必须与参照列的数据类型必须相同（数值型要求长度和无符号都相同，字符串要求类型相同，长度可以不同）")])])])]),v._v(" "),t("h5",{attrs:{id:"什么是完全函数依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是完全函数依赖"}},[v._v("#")]),v._v(" 什么是完全函数依赖？")]),v._v(" "),t("ul",[t("li",[v._v("部分函数依赖")])]),v._v(" "),t("blockquote",[t("p",[v._v("关系模式 成绩(学号, 姓名, 课程编号, 成绩)")]),v._v(" "),t("p",[v._v("取X=(学号, 课程编号), Y= 姓名")]),v._v(" "),t("p",[v._v("显然:  X→Y")]),v._v(" "),t("p",[v._v("但实际上, 姓名仅仅依赖于 X的一个真子集 (学号)，也就是说Y部分依赖于X.")])]),v._v(" "),t("ul",[t("li",[v._v("完全函数依赖")])]),v._v(" "),t("blockquote",[t("p",[v._v("关系模式 成绩(学号, 姓名, 课程编号, 成绩)")]),v._v(" "),t("p",[v._v("取X=(学号, 课程编号), Y= 成绩")]),v._v(" "),t("p",[v._v("显然:  X→Y")]),v._v(" "),t("p",[v._v("X的真子集 为(学号)、(课程编号)，这两个真子集都不能单独决定成绩, 此时, 称Y完全依赖于X.")])])])}),[],!1,null,null,null);_.default=a.exports}}]);