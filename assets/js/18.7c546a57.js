(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{445:function(t,r,e){"use strict";e.r(r);var n=e(15),o=Object(n.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("java中的异常处理是基于面向对象的一种运行态错误处理机制，通过对异常信息的封装实现对用户非法操作、参数设置异常、硬件系统异常，运行时网络状态更换等在运行态中可能出现的异常信息的处理机制。")]),t._v(" "),e("h5",{attrs:{id:"异常结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常结构"}},[t._v("#")]),t._v(" 异常结构")]),t._v(" "),e("p",[t._v("Throwable分成了两个不同的分支，一个分支是Error，它表示不希望被程序捕获或者是程序无法处理的错误。另一个分支是Exception，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常。")]),t._v(" "),e("p",[e("strong",[t._v("Error")]),t._v("：Error类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通常是使用Error的子类描述。")]),t._v(" "),e("p",[e("strong",[t._v("Exception")]),t._v("：在Exception分支中有一个重要的子类RuntimeException（运行时异常），该类型的异常自动为你所编写的程序定义，通常有下列运行时异常")]),t._v(" "),e("ul",[e("li",[t._v("ArrayIndexOutOfBoundsException（数组下标越界）")]),t._v(" "),e("li",[t._v("NullPointerException（空指针异常）")]),t._v(" "),e("li",[t._v("ArithmeticException（算术异常）")]),t._v(" "),e("li",[t._v("MissingResourceException（丢失资源）")]),t._v(" "),e("li",[t._v("ClassNotFoundException（找不到类）")]),t._v(" "),e("li",[t._v("etc......")])]),t._v(" "),e("p",[t._v("这些异常是非受检性异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而RuntimeException之外的异常我们统称为非运行时异常，类型上属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义受检检性异常。")]),t._v(" "),e("h5",{attrs:{id:"异常类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常类型"}},[t._v("#")]),t._v(" 异常类型")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("运行时异常：")]),t._v(" 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("错误：")]),t._v(" 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。")])])]),t._v(" "),e("h5",{attrs:{id:"抛出异常的规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抛出异常的规则"}},[t._v("#")]),t._v(" 抛出异常的规则")]),t._v(" "),e("ul",[e("li",[t._v("如果是非受检查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。")]),t._v(" "),e("li",[t._v("必须声明方法可抛出的任何检查异常（checked exception）。即如果一个方法可能出现受检性异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误。")]),t._v(" "),e("li",[t._v("仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。")])]),t._v(" "),e("p",[t._v("调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。")]),t._v(" "),e("h5",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/yongyuai/article/details/79752608",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章1"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/Qian123/p/5715402.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章2"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=o.exports}}]);