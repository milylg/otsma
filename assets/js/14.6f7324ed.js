(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{443:function(r,t,e){"use strict";e.r(t);var a=e(15),s=Object(a.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h4",{attrs:{id:"failure和error的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#failure和error的区别"}},[r._v("#")]),r._v(" Failure和Error的区别")]),r._v(" "),e("p",[r._v("JUnit 将测试失败的情况分为两种：Failure 和 Error 。")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("Failure 一般是由单元测试使用的断言方法判断失败引起的，它表示在测试点发现了问题（程序中的 bug）；")])]),r._v(" "),e("li",[e("p",[r._v("Error 则是有代码异常引起的，这是测试目的之外的发现，它可能产生于测试代码本身的错误。")])])]),r._v(" "),e("h4",{attrs:{id:"常用注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用注解"}},[r._v("#")]),r._v(" 常用注解")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("@Before ：初始化方法，在任何一个测试方法执行之前，必须执行的代码。")])]),r._v(" "),e("li",[e("p",[r._v("@Test ：测试方法，表明这是一个测试方法。")])]),r._v(" "),e("li",[e("p",[r._v("@After ：在任何一个测试方法执行之后，需要进行的收尾工作。")])]),r._v(" "),e("li",[e("p",[r._v("@Ignore ：忽略的测试方法")])]),r._v(" "),e("li",[e("p",[r._v("@Parameters ：参数化测试为测试类声明一个注解@Parameters，返回值为Collection的公共静态方法，并初始化所有需要测试的参数对")])])]),r._v(" "),e("h4",{attrs:{id:"单元测试编写规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单元测试编写规范"}},[r._v("#")]),r._v(" 单元测试编写规范")]),r._v(" "),e("ul",[e("li",[r._v("有意义的测试方法名")]),r._v(" "),e("li",[r._v("测试的独立性：每项单元测试都必须独立于其他所有单元测试而运行")]),r._v(" "),e("li",[r._v("为暂时未实现的测试代码忽略（@Ignore）或抛出失败（fail）")]),r._v(" "),e("li",[r._v("在调用断言（assert）方法时给出失败的原因：使用带有 message 参数的 API ，并在调用时给出失败时的原因描述")])]),r._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[r._v("单元测试的目的")]),r._v(" "),e("p",[r._v("测试任何可能的错误。单元测试不是用来证明您是对的，而是为了证明您没有错。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);