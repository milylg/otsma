(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{473:function(t,_,v){"use strict";v.r(_);var e=v(15),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h4",{attrs:{id:"索引分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引分类"}},[t._v("#")]),t._v(" 索引分类")]),t._v(" "),v("h5",{attrs:{id:"类型-应用角度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类型-应用角度"}},[t._v("#")]),t._v(" 类型（应用角度）")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("普通索引")])]),t._v(" "),v("li",[t._v("复合索引(普通索引的扩展)")]),t._v(" "),v("li",[v("strong",[t._v("唯一索引")])]),t._v(" "),v("li",[v("strong",[t._v("全文索引")])])]),t._v(" "),v("h5",{attrs:{id:"类型-物理角度-存储结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类型-物理角度-存储结构"}},[t._v("#")]),t._v(" 类型（物理角度：存储结构）")]),t._v(" "),v("ul",[v("li",[t._v("聚簇索引 "),v("strong",[t._v("(CLUSTERED INDEX)")]),t._v(" "),v("ul",[v("li",[t._v("聚簇索引的叶子节点就是数据节点")]),t._v(" "),v("li",[t._v("存储记录是物理上连续存在")]),t._v(" "),v("li",[t._v("每个表有且仅有一个聚簇引擎")]),t._v(" "),v("li",[t._v("叶子节点是实际的数据页，按照索引顺序存储")]),t._v(" "),v("li",[t._v("PRIMARY KEY约束自动创建聚集索引")]),t._v(" "),v("li",[t._v("For Example\n"),v("ul",[v("li",[t._v("以字典为例，收录的字词是按照a-z排序的，拼音目录就是具有连续性的，这就是聚集索引。")])])])])]),t._v(" "),v("li",[t._v("非聚簇索引 "),v("strong",[t._v("(NONCLUSTERED INDEX)")]),t._v(" "),v("ul",[v("li",[t._v("非聚簇索引的叶子节点是索引节点，里面有指向对应数据块的指针")]),t._v(" "),v("li",[t._v("每个表可能有多个非聚簇索引")]),t._v(" "),v("li",[t._v("非聚集索引根据索引列不同提供不同的排序顺序")]),t._v(" "),v("li",[t._v("叶节点是指向数据的指针")]),t._v(" "),v("li",[t._v("For Example\n"),v("ul",[v("li",[t._v("字典中偏旁部首目录就属于非聚集索引")])])])])])]),t._v(" "),v("p",[t._v("聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致")]),t._v(" "),v("h6",{attrs:{id:"简单概括"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单概括"}},[t._v("#")]),t._v(" 简单概括")]),t._v(" "),v("ul",[v("li",[t._v("聚集索引：就是以主键创建的索引。")]),t._v(" "),v("li",[t._v("非聚集索引：就是以非主键创建的索引（也叫做二级索引）。")])]),t._v(" "),v("h6",{attrs:{id:"详细概括"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#详细概括"}},[t._v("#")]),t._v(" 详细概括")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("聚集索引")])])]),t._v(" "),v("p",[t._v("聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。")]),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v("：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("非聚集索引")])])]),t._v(" "),v("p",[t._v("索引的逻辑顺序与磁盘上行的物理存储顺序不同，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是我们所说的回表。")]),t._v(" "),v("h6",{attrs:{id:"聚集索引和非聚集索引的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和非聚集索引的区别"}},[t._v("#")]),t._v(" 聚集索引和非聚集索引的区别")]),t._v(" "),v("ul",[v("li",[t._v("聚集索引在叶子节点存储的是表中的数据。")]),t._v(" "),v("li",[t._v("非聚集索引在叶子节点存储的是主键和索引列。")])]),t._v(" "),v("h4",{attrs:{id:"两种索引方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两种索引方式"}},[t._v("#")]),t._v(" 两种索引方式")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("B-Tree索引")]),t._v(" "),v("ul",[v("li",[t._v("范围查找")]),t._v(" "),v("li",[t._v("前缀查找")])])]),t._v(" "),v("li",[v("p",[t._v("哈希索引")])])]),t._v(" "),v("h5",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),v("ul",[v("li",[t._v("优化查询速度")]),t._v(" "),v("li",[t._v("加快表之间的关联速度")])]),t._v(" "),v("h5",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),v("ul",[v("li",[t._v("需要磁盘空间存储索引信息")]),t._v(" "),v("li",[t._v("降低数据维护操作的执行速度")])]),t._v(" "),v("h4",{attrs:{id:"索引实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引实践"}},[t._v("#")]),t._v(" 索引实践")]),t._v(" "),v("h4",{attrs:{id:"如何创建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何创建索引"}},[t._v("#")]),t._v(" 如何创建索引？")]),t._v(" "),v("h5",{attrs:{id:"在已有的表中创建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在已有的表中创建索引"}},[t._v("#")]),t._v(" 在已有的表中创建索引")]),t._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("CREATE INDEX 索引名称 ON 表名(列名, ...)\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("div",{staticClass:"language-MYSQL line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL]  [INDEX|KEY] 索引名(列名（长度))  [ASC|DESC]\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h5",{attrs:{id:"在表中创建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在表中创建索引"}},[t._v("#")]),t._v(" 在表中创建索引")]),t._v(" "),v("div",{staticClass:"language-MYSQL line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("CREATE TABLE 表名（\n     列名  数据类型  约束，\n     ......,\n     INDEX(列名)）;\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("索引类型")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("创建方式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("普通索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("INDEX(列名)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("复合索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("INDEX(列名，列名，......)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("唯一索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("UNIQUE INDEX(列名)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("主键索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("PRIMAERY KEY(主键)")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("全文索引")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("FULLTEXT iNDEX(列名)")])])])]),t._v(" "),v("h5",{attrs:{id:"如何查询索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何查询索引"}},[t._v("#")]),t._v(" 如何查询索引?")]),t._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("SHOW INDEXES FROM 表名;\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"images/%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82.png",alt:""}})]),t._v(" "),v("h5",{attrs:{id:"索引信息包含的描述信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引信息包含的描述信息"}},[t._v("#")]),t._v(" 索引信息包含的描述信息")]),t._v(" "),v("ul",[v("li",[t._v("Table : 表名。")]),t._v(" "),v("li",[t._v("Non_unique : 如果索引可以包含重复项，则为1；如果不能包含重复项，则为0。")]),t._v(" "),v("li",[t._v("Key_name : 索引名称。该"),v("a",{attrs:{href:"https://www.mysqltutorial.org/mysql-primary-key/",target:"_blank",rel:"noopener noreferrer"}},[t._v("主键"),v("OutboundLink")],1),t._v("索引始终具有的名称"),v("code",[t._v("PRIMARY")]),t._v("。")]),t._v(" "),v("li",[t._v("Seq_in_index : 索引中的列序号。第一列序列号从1开始。")]),t._v(" "),v("li",[t._v("Column_name : 列名")]),t._v(" "),v("li",[t._v("Collation : 排序规则表示如何在索引中对列进行排序。"),v("code",[t._v("A")]),t._v("表示上升，"),v("code",[t._v("B")]),t._v("表示下降或"),v("code",[t._v("NULL")]),t._v("表示未排序。")]),t._v(" "),v("li",[t._v("Cardinality : 基数在索引中返回估计的唯一值数量。基数越高，查询优化器使用索引进行查找的机会就越大。")]),t._v(" "),v("li",[t._v("Sub_part : 索引前缀。如果整个列都已索引，则为null。否则，如果列被部分索引，它会显示索引字符的数量。")]),t._v(" "),v("li",[t._v("Packet : 表示密钥的包装方式；如果不是，则为NUL。")]),t._v(" "),v("li",[t._v("Null : "),v("code",[t._v("YES")]),t._v(" 如果该列可能包含NULL值，则为空。")]),t._v(" "),v("li",[t._v("Index_type : 表示使用诸如索引方法"),v("code",[t._v("BTREE")]),t._v("，"),v("code",[t._v("HASH")]),t._v("，"),v("code",[t._v("RTREE")]),t._v("，或"),v("code",[t._v("FULLTEXT")]),t._v("。")]),t._v(" "),v("li",[t._v("Comment : 有关索引的信息未在其自己的列中描述。")]),t._v(" "),v("li",[t._v("Index_comment : 显示使用"),v("code",[t._v("COMMENT")]),t._v("属性创建索引时指定索引的注释。")])]),t._v(" "),v("h5",{attrs:{id:"如何删除索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何删除索引"}},[t._v("#")]),t._v(" 如何删除索引？")]),t._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("DROP INDEX 索引名 ON 表名;\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h4",{attrs:{id:"最佳实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),v("ul",[v("li",[t._v("模糊查询命中不了索引，即索引失效。除此之外，还有"),v("code",[t._v("or")]),t._v("，"),v("code",[t._v("通配符开头")]),t._v("，"),v("code",[t._v("使用不等于（!= 、<>）")]),t._v("等情况")]),t._v(" "),v("li",[t._v("建议使用IN")]),t._v(" "),v("li",[t._v("定义主键或外键的数据列一定要建立索引")]),t._v(" "),v("li",[t._v("索引列不要使用聚集函数")]),t._v(" "),v("li",[t._v("已知查询结果只有一条，建议使用LIMIT来避免全文扫描")]),t._v(" "),v("li",[t._v("分页时直接limit n 5可能用不到索引，假设索引列是ID，那么我们使用where id > n limit 5就可以实现上述操作了")]),t._v(" "),v("li",[t._v("经常出现在关键字order by、group by、distinct后面的字段建立索引")]),t._v(" "),v("li",[t._v("建立复合索引，建议将区分度高的列放到最左端")]),t._v(" "),v("li",[t._v("更新频繁，且区分度不高的字段不宜建立索引")]),t._v(" "),v("li",[t._v("建立索引的列不能为NULL")]),t._v(" "),v("li",[t._v("数据类型不宜隐式转换（例如varchar转成int）")]),t._v(" "),v("li",[t._v("不用外键，由程序保证约束")]),t._v(" "),v("li",[t._v("尽量不用"),v("code",[t._v("UNIQUE")]),t._v("，由程序保证约束")]),t._v(" "),v("li",[t._v("使用多列索引时主键顺序和查询条件保持一致，同时删除不必要的单列索引")])]),t._v(" "),v("h4",{attrs:{id:"如何查看执行计划"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何查看执行计划"}},[t._v("#")]),t._v(" 如何查看执行计划")]),t._v(" "),v("h5",{attrs:{id:"语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("EXPLAIN 查询语句\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h5",{attrs:{id:"案例-没有使用索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#案例-没有使用索引"}},[t._v("#")]),t._v(" 案例（没有使用索引）")]),t._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("select * from cn_area where short_name = '小崔庄';\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("blockquote",[v("p",[v("strong",[t._v("第一次查询")])]),t._v(" "),v("p",[t._v("[SQL] select * from cn_area where short_name = '小崔庄';")]),t._v(" "),v("p",[t._v("受影响的行: 0")]),t._v(" "),v("p",[t._v("时间: 2.361s")]),t._v(" "),v("p",[v("strong",[t._v("第二次查询")])]),t._v(" "),v("p",[t._v("[SQL] select * from cn_area where short_name = '小崔庄';")]),t._v(" "),v("p",[t._v("受影响的行: 0")]),t._v(" "),v("p",[t._v("时间: 0.698s")])]),t._v(" "),v("p",[t._v("相比第一次查询，第二次查询明显变快了的主要原因是查询命中缓存了，没有进行数据查询操作了，跟索引没有关系。")]),t._v(" "),v("p",[t._v("查询结果：")]),t._v(" "),v("p",[v("img",{attrs:{src:"images%5C%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA.png",alt:""}})]),t._v(" "),v("p",[t._v("执行计划：")]),t._v(" "),v("p",[v("img",{attrs:{src:"images%5C%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%BB%93%E6%9E%9C.png",alt:""}})]),t._v(" "),v("p",[t._v("从上面的执行计划可以看出查询并没有使用索引。")]),t._v(" "),v("p",[t._v("先查询表中使用了哪些索引，然后观察查询关键字是索引列的时候，执行计划是怎样的。运行"),v("code",[t._v("show indexes from cn_area;")]),t._v("SQL语句。结果如下："),v("img",{attrs:{src:"images%5C%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82.png",alt:""}})]),t._v(" "),v("p",[t._v("可以看出索引列有 "),v("code",[t._v("id")]),t._v("，"),v("code",[t._v("area_code")]),t._v("，"),v("code",[t._v("parent_code")]),t._v("，当使用索引列作为查询关键字的时候，会触发使用索引。")]),t._v(" "),v("p",[t._v("使用"),v("code",[t._v('explain select * from cn_area where area_code = "131127204216";')]),t._v("查询的过程中使用到索引：")]),t._v(" "),v("p",[v("img",{attrs:{src:"images%5C%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png",alt:""}})]),t._v(" "),v("h4",{attrs:{id:"执行计划中的参数含义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行计划中的参数含义"}},[t._v("#")]),t._v(" 执行计划中的参数含义")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("Column")]),t._v(" "),v("th",[t._v("JSON Name")]),t._v(" "),v("th",[t._v("Meaning")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("id")]),t._v(" "),v("td",[t._v("select_id")]),t._v(" "),v("td",[t._v("The SELECT identifier")])]),t._v(" "),v("tr",[v("td",[t._v("select_type")]),t._v(" "),v("td",[t._v("None")]),t._v(" "),v("td",[t._v("The SELECT type")])]),t._v(" "),v("tr",[v("td",[t._v("table")]),t._v(" "),v("td",[t._v("table_name")]),t._v(" "),v("td",[t._v("The table for the output row")])]),t._v(" "),v("tr",[v("td",[t._v("partitions")]),t._v(" "),v("td",[t._v("partitions")]),t._v(" "),v("td",[t._v("The matching partitions")])]),t._v(" "),v("tr",[v("td",[t._v("type")]),t._v(" "),v("td",[t._v("access_type")]),t._v(" "),v("td",[t._v("The join type")])]),t._v(" "),v("tr",[v("td",[t._v("possible_keys")]),t._v(" "),v("td",[t._v("possible_keys")]),t._v(" "),v("td",[t._v("The possible indexes to choose")])]),t._v(" "),v("tr",[v("td",[t._v("key")]),t._v(" "),v("td",[t._v("key")]),t._v(" "),v("td",[t._v("The index actually chosen")])]),t._v(" "),v("tr",[v("td",[t._v("key_len")]),t._v(" "),v("td",[t._v("key_length")]),t._v(" "),v("td",[t._v("The length of the chosen key")])]),t._v(" "),v("tr",[v("td",[t._v("ref")]),t._v(" "),v("td",[t._v("ref")]),t._v(" "),v("td",[t._v("The columns compared to the index")])]),t._v(" "),v("tr",[v("td",[t._v("rows")]),t._v(" "),v("td",[t._v("rows")]),t._v(" "),v("td",[t._v("Estimate of rows to be examined")])]),t._v(" "),v("tr",[v("td",[t._v("filtered")]),t._v(" "),v("td",[t._v("filtered")]),t._v(" "),v("td",[t._v("Percentage of rows filtered by table condition")])]),t._v(" "),v("tr",[v("td",[t._v("Extra")]),t._v(" "),v("td",[t._v("None")]),t._v(" "),v("td",[t._v("Additional information")])])])]),t._v(" "),v("p",[t._v("待记录列的选项代表的作用，以后复习的时候再记录。")]),t._v(" "),v("p",[t._v("先记录几个比较重要的描述列")]),t._v(" "),v("p",[v("strong",[t._v("select_type")])]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("SIMPLE")]),t._v("(简单SELECT,不使用UNION或子查询等)")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("PRIMARY")]),t._v("(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("UNION")]),t._v("(UNION中的第二个或后面的SELECT语句)")])]),t._v(" "),v("li",[v("p",[t._v("ETC.......")])])]),t._v(" "),v("p",[v("strong",[t._v("type")])]),t._v(" "),v("p",[t._v("表示MySQL在表中找到所需行的方式，又称“访问类型”。")]),t._v(" "),v("p",[t._v("常用的类型有： "),v("strong",[t._v("ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("type")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("description")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("ALL：Full Table Scan")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("遍历全表以找到匹配的行")])]),t._v(" "),v("tr",[v("td",[t._v("index: Full Index Scan")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("index与ALL区别为index类型只遍历索引树")])]),t._v(" "),v("tr",[v("td",[t._v("range")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("只检索给定范围的行，使用一个索引来选择行")])]),t._v(" "),v("tr",[v("td",[t._v("ref")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值")])]),t._v(" "),v("tr",[v("td",[t._v("eq_ref")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("类似ref，区别就在使用的索引是唯一索引")])]),t._v(" "),v("tr",[v("td",[t._v("const、system")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问")])]),t._v(" "),v("tr",[v("td",[t._v("NULL")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("MySQL在优化过程中分解语句，执行时甚至不用访问表或索引")])])])]),t._v(" "),v("p",[v("strong",[t._v("key")])]),t._v(" "),v("p",[t._v("key列显示MySQL实际决定使用的键（索引）")]),t._v(" "),v("p",[t._v("如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。")]),t._v(" "),v("p",[v("strong",[t._v("key_len")])]),t._v(" "),v("p",[t._v("表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）")]),t._v(" "),v("p",[t._v("不损失精确性的情况下，长度越短越好")]),t._v(" "),v("h4",{attrs:{id:"索引底层原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引底层原理"}},[t._v("#")]),t._v(" 索引底层原理")]),t._v(" "),v("h5",{attrs:{id:"b-tree模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree模型"}},[t._v("#")]),t._v(" B+Tree模型")]),t._v(" "),v("p",[t._v("B+ 树，也是 MySQL 索引大部分情况所使用的数据结构。")]),t._v(" "),v("p",[v("img",{attrs:{src:"images%5CB+Tree.png",alt:""}})]),t._v(" "),v("h5",{attrs:{id:"b-树基本特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树基本特点"}},[t._v("#")]),t._v(" B+ 树基本特点")]),t._v(" "),v("ul",[v("li",[t._v("非叶子节点的子树指针与关键字个数相同。")]),t._v(" "),v("li",[t._v("非叶子节点的子树指针 P[i]，指向关键字属于 "),v("strong",[t._v("[k[i],K[i+1])")]),t._v(" 的子树（"),v("strong",[t._v("注意：区间是前闭后开")]),t._v(")。")]),t._v(" "),v("li",[v("strong",[t._v("为所有叶子节点增加一个链指针")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("所有关键字都在叶子节点出现")]),t._v("。")])]),t._v(" "),v("h5",{attrs:{id:"b-树的特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树的特性"}},[t._v("#")]),t._v(" B+ 树的特性")]),t._v(" "),v("ul",[v("li",[t._v("所有的关键字 "),v("strong",[t._v("都出现在叶子节点的链表中")]),t._v("，且链表中的关键字是有序的。")]),t._v(" "),v("li",[v("strong",[t._v("搜索只在叶子节点命中")]),t._v("。")]),t._v(" "),v("li",[t._v("非叶子节点相当于是 "),v("strong",[t._v("叶子节点的索引层")]),t._v("，叶子节点是 "),v("strong",[t._v("存储关键字数据的数据层")]),t._v("。")])]),t._v(" "),v("h4",{attrs:{id:"b-tree模型-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree模型-2"}},[t._v("#")]),t._v(" B-Tree模型：")]),t._v(" "),v("p",[v("img",{attrs:{src:"images%5CB-Tree%E6%A8%A1%E5%9E%8B.png",alt:""}})]),t._v(" "),v("h5",{attrs:{id:"b-树的特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树的特点"}},[t._v("#")]),t._v(" B 树的特点：")]),t._v(" "),v("ul",[v("li",[t._v("关键字分布在整棵树的所有节点。")]),t._v(" "),v("li",[t._v("任何一个关键字 "),v("strong",[t._v("出现且只出现在一个节点中")]),t._v("。")]),t._v(" "),v("li",[t._v("搜索有可能在 "),v("strong",[t._v("非叶子节点")]),t._v(" 结束。")]),t._v(" "),v("li",[t._v("其搜索性能等价于在关键字全集内做一次二分查找")])]),t._v(" "),v("h4",{attrs:{id:"mysql为什么使用b-tree而不使用b-tree"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql为什么使用b-tree而不使用b-tree"}},[t._v("#")]),t._v(" MySQL为什么使用B+Tree而不使用B-Tree？")]),t._v(" "),v("p",[v("strong",[t._v("B树")]),t._v("的"),v("strong",[t._v("非叶子节点")]),t._v("中既保存了指针也保存了数据，这样一个"),v("strong",[t._v("节点（页）"),v("strong",[t._v("中存储的指针的数量就会变少，导致树的高度变高，从而")]),t._v("I/O")]),t._v("次数变多，影响查询性能。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("存储位置")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("最小单元")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("存储大小")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("磁盘")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("扇区")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("512 Byte")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("文件系统")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("块")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("4K Byte")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("InnoDB")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("页")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("16K Byte")])])])]),t._v(" "),v("p",[t._v("相对 B 树，B+ 树做索引的优势")]),t._v(" "),v("ul",[v("li",[t._v("B+ 树的磁盘读写代价更低。"),v("strong",[t._v("B+ 树的内部没有指向关键字具体信息的指针")]),t._v("，所以其内部节点相对 B 树更小，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，"),v("strong",[t._v("相应的，IO 读写次数就降低了")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("树的查询效率更加稳定")]),t._v("。B+ 树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而 B 树可能在非叶子节点就停止查找了，所以查询效率不够稳定。")]),t._v(" "),v("li",[v("strong",[t._v("B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历")]),t._v("。")])]),t._v(" "),v("h5",{attrs:{id:"sql查询语句优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql查询语句优化"}},[t._v("#")]),t._v(" SQL查询语句优化")]),t._v(" "),v("ul",[v("li",[t._v("mysql嵌套子查询效率确实比较低")]),t._v(" "),v("li",[t._v("可以将其优化成连接查询")]),t._v(" "),v("li",[t._v("连接表时，可以先用where条件对表进行过滤，然后做表连接（虽然mysql会对连表语句做优化）")]),t._v(" "),v("li",[t._v("建立合适的索引，必要时建立多列联合索引")]),t._v(" "),v("li",[t._v("学会分析sql执行计划，mysql会对sql进行优化，所以分析执行计划很重要")])]),t._v(" "),v("h5",{attrs:{id:"查询最佳实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查询最佳实践"}},[t._v("#")]),t._v(" 查询最佳实践")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("列类型尽量定义成数值类型，且长度尽可能短，如主键和外键，类型字段等等")])]),t._v(" "),v("li",[v("p",[t._v("建立单列索引")])]),t._v(" "),v("li",[v("p",[t._v("根据需要建立多列联合索引,当单个列过滤之后还有很多数据，那么索引的效率将会比较低，即列的区分度较低，那么如果在多个列上建立索引，那么多个列的区分度就大多了，将会有显著的效率提高。")])]),t._v(" "),v("li",[v("p",[t._v("根据业务场景建立覆盖索引")])]),t._v(" "),v("li",[v("p",[t._v("只查询业务需要的字段，如果这些字段被索引覆盖，将极大的提高查询效率")])]),t._v(" "),v("li",[v("p",[t._v("多表连接的字段上需要建立索引,这样可以极大的提高表连接的效率")])]),t._v(" "),v("li",[v("p",[t._v("where条件字段上需要建立索引")])]),t._v(" "),v("li",[v("p",[t._v("排序字段上需要建立索引")])]),t._v(" "),v("li",[v("p",[t._v("分组字段上需要建立索引")])]),t._v(" "),v("li",[v("p",[t._v("Where条件上不要使用运算函数，以免索引失效")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);